/**
 * BTX Generation API
 *
 * POST /api/ko/takeoff/[projectId]/btx
 * Generates a Bluebeam BTX tool chest file from the project's takeoff configuration.
 *
 * The generated tools use the PIPE delimiter format:
 *   Subject = "ITEM_CODE | LOCATION"
 *   e.g., "MR-VB | FL1", "MR-2PLY | ROOF"
 *
 * This enables deterministic parsing when the CSV is imported back.
 */

import { NextResponse } from 'next/server'
import https from 'https'
import zlib from 'zlib'

const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'https://136.111.252.120'

// Custom fetch that ignores SSL cert errors
const fetchWithSSL = async (url, options = {}) => {
  const agent = new https.Agent({ rejectUnauthorized: false })
  return fetch(url, { ...options, agent })
}

// Tool type configurations based on UOM
const TOOL_CONFIGS = {
  SF: {
    toolType: 'AnnotationMeasureArea',
    color: '#FF0000',
    lineWidth: 2,
    opacity: 0.3,
    fillColor: '#FF000040'
  },
  LF: {
    toolType: 'AnnotationMeasurePolylength',
    color: '#0000FF',
    lineWidth: 2,
    opacity: 1.0,
    fillColor: null
  },
  EA: {
    toolType: 'AnnotationMeasureCount',
    color: '#00FF00',
    lineWidth: 2,
    opacity: 1.0,
    fillColor: null
  }
}

// Standard location codes
const LOCATION_CODES = {
  'Main Roof': 'ROOF',
  '1st Floor': 'FL1',
  '2nd Floor': 'FL2',
  '3rd Floor': 'FL3',
  '4th Floor': 'FL4',
  'Stair Bulkhead': 'STAIR',
  'Elev Bulkhead': 'ELEV',
  'Front': 'FRONT',
  'Rear': 'REAR',
  'North': 'NORTH',
  'South': 'SOUTH',
  'East': 'EAST',
  'West': 'WEST'
}

/**
 * Generate a unique tool ID
 */
function generateToolId() {
  return 'tool_' + Math.random().toString(36).substr(2, 9)
}

/**
 * Compress tool data using zlib (Bluebeam BTX format)
 */
function compressToolData(data) {
  return zlib.deflateSync(Buffer.from(data, 'utf-8')).toString('base64')
}

/**
 * Generate BTX XML content
 */
function generateBTXContent(tools, projectName) {
  const toolsXml = tools.map(tool => {
    // The Subject field will be in the format "ITEM_CODE | LOCATION"
    const toolId = generateToolId()

    // Create compressed annotation data (simplified - Bluebeam uses a more complex format)
    const annotData = JSON.stringify({
      Subject: tool.subject,
      ToolType: tool.toolType,
      Color: tool.color,
      LineWidth: tool.lineWidth
    })

    return `
    <ToolChestItem Id="${toolId}" Name="${tool.displayName}">
      <Subject>${escapeXml(tool.subject)}</Subject>
      <ToolType>${tool.toolType}</ToolType>
      <Color>${tool.color}</Color>
      <LineWidth>${tool.lineWidth}</LineWidth>
      <Opacity>${tool.opacity}</Opacity>
      ${tool.fillColor ? `<FillColor>${tool.fillColor}</FillColor>` : ''}
      <Category>${tool.category}</Category>
      <UOM>${tool.uom}</UOM>
    </ToolChestItem>`
  }).join('\n')

  return `<?xml version="1.0" encoding="UTF-8"?>
<BluebeamRevuToolSet Version="1.0" Name="${escapeXml(projectName)} Takeoff Tools" CreatedBy="KO System">
  <Description>Deterministic takeoff tools for ${escapeXml(projectName)}. Generated by KO System.</Description>
  <Tools>
${toolsXml}
  </Tools>
</BluebeamRevuToolSet>`
}

/**
 * Escape XML special characters
 */
function escapeXml(str) {
  if (!str) return ''
  return str
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&apos;')
}

/**
 * POST /api/ko/takeoff/[projectId]/btx
 * Generate BTX file from configuration
 */
export async function POST(request, { params }) {
  try {
    const { projectId } = await params
    const body = await request.json()

    // Get config from request body or fetch from storage
    let config = body.config

    if (!config) {
      // Try to fetch saved config
      const configRes = await fetch(`${request.nextUrl.origin}/api/ko/takeoff/${projectId}/config`)
      if (configRes.ok) {
        const configData = await configRes.json()
        if (configData.exists && configData.config) {
          config = configData.config
        }
      }
    }

    if (!config || !config.columns || !config.selectedItems) {
      return NextResponse.json(
        { error: 'No takeoff configuration found. Please set up the takeoff first.' },
        { status: 400 }
      )
    }

    const { columns, selectedItems } = config
    const projectName = body.projectName || projectId

    // Generate tools for each item Ã— location combination
    const tools = []

    for (const item of selectedItems) {
      const itemCode = item.scope_code
      const itemName = item.scope_name || itemCode

      // Determine tool type based on UOM
      const uom = item.uom || 'SF'
      const toolConfig = TOOL_CONFIGS[uom] || TOOL_CONFIGS.SF

      // Create a tool for each location column
      for (const column of columns) {
        // Use first mapping as the location code, or generate from name
        let locationCode = column.mappings?.[0] || LOCATION_CODES[column.name]
        if (!locationCode) {
          // Generate code from name (e.g., "Main Roof" -> "MAINROOF")
          locationCode = column.name.toUpperCase().replace(/[^A-Z0-9]/g, '')
        }

        // Create subject in PIPE format: "ITEM_CODE | LOCATION"
        const subject = `${itemCode} | ${locationCode}`

        // Display name for the tool in Bluebeam toolbar
        const displayName = `${itemName} - ${column.name}`

        tools.push({
          subject,
          displayName,
          category: item.section || 'General',
          uom,
          ...toolConfig
        })
      }
    }

    if (tools.length === 0) {
      return NextResponse.json(
        { error: 'No tools generated. Check that items and locations are configured.' },
        { status: 400 }
      )
    }

    // Generate BTX XML
    const btxContent = generateBTXContent(tools, projectName)

    // Return the BTX file
    return new NextResponse(btxContent, {
      status: 200,
      headers: {
        'Content-Type': 'application/xml',
        'Content-Disposition': `attachment; filename="${projectName.replace(/[^a-zA-Z0-9]/g, '_')}_Takeoff.btx"`,
        'X-Tool-Count': tools.length.toString()
      }
    })

  } catch (err) {
    console.error('BTX generation error:', err)
    return NextResponse.json(
      { error: 'Failed to generate BTX: ' + err.message },
      { status: 500 }
    )
  }
}

/**
 * GET /api/ko/takeoff/[projectId]/btx
 * Get info about what would be generated
 */
export async function GET(request, { params }) {
  try {
    const { projectId } = await params

    // Fetch saved config
    const configRes = await fetch(`${request.nextUrl.origin}/api/ko/takeoff/${projectId}/config`)
    if (!configRes.ok) {
      return NextResponse.json({
        ready: false,
        message: 'No configuration found'
      })
    }

    const configData = await configRes.json()
    if (!configData.exists || !configData.config) {
      return NextResponse.json({
        ready: false,
        message: 'Configuration not complete'
      })
    }

    const { columns, selectedItems } = configData.config
    const toolCount = (selectedItems?.length || 0) * (columns?.length || 0)

    return NextResponse.json({
      ready: true,
      toolCount,
      items: selectedItems?.length || 0,
      locations: columns?.length || 0,
      message: `Ready to generate ${toolCount} tools`
    })

  } catch (err) {
    console.error('BTX info error:', err)
    return NextResponse.json(
      { error: err.message },
      { status: 500 }
    )
  }
}
